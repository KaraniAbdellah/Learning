// What I Will Learn
/*
    - Getting Started with Spring Boot
    - Dependency Injection (DI)
    - Database Integration With Spring Boot (JPA)
    - Understand The Project Structure
    - Build and run first application
    -----------
    - Using Spring Boot DevTools
    - Configuring your application
    - Debugging your application
*/



// Intro Spring vs Spring Boot
/*
    - Both of them is Framework
    - The Problem with Problem is slowly in production (some tasks manually)
    - Spring Boot fix that (ready to use feature) --> Save Time
*/



// Project Structure
/*
    pom.xml --> Project Object Model is file that
        maven define configuration, dependencies.
        Like package.json
    main --> folder we write application
        java --> write java code
            SpringBootDabastockApplication: Entries Point
        resources --> no java file [config like PORT, URLDB]
*/



// Dependencies Management
/*
    for building web app we need:
        tomcat, web libs, webmvc(building APIS)

    instead of use all that we can use "Starter Dependency"
        --> use Maven Control --> like npm, ...

    the best practice if to remove version from dependencies --> it inherit version
*/



// Building First Controllers
/*
    Spring MVC (mode, vue, controller):
        mode = data + logic (connect to db)
        view = what the users sees
        controller = Mediator
*/



// Running Spring Boot Application && Debugging
/*
    Running:
        - ./mvnw spring-boot:run --> run it in terminal
        - click to run button
    Debugging:
        Using Terminal
        Using IntelliJ Debugger --> I Do not Understand this lesson know "may be letter"
*/



// Auto Restart
/*
    install spring-boot-devtools:
        add tags <optional>true</optional>
            --> means this pack used just in development not in production
*/



// Configuration Application Properties
/*
    Any Every Application We Need to configure a different setting:
*/
package controllers;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
@Controller
public class HomeController {
    @Value("${spring.application.name}") // this value exit in application.properties
    private String appName;
    s@RequestMapping("/")
    public String index() {
        System.out.println(appName); // learn_spring_store
        return "index.html";
    }
}



// Dependency Injection
/*
    what is ID:
        For Example in Ecommerce platform --> we have "OrderService" class depend to an API "StripePaymentService"
            --> The problem is that if we want to change the API --> need to change the "OrderService" code
            Issue: how dependencies are managed
        We can create an interface "PaymentService" --> and has "Stripe || Paypal" class (inheritance)

    Injection Dependency in Class [Constractor Injection, Setter Injection]:
*/

// App.java
public class LearnSpringStoreApplication {
	public static void main(String[] args) {
		// SpringApplication.run(LearnSpringStoreApplication.class, args);
		var OrderService = new OrderService(new PaypalPaymentService());
		OrderService.placeholder();
		OrderService.setPaymentService(new StripePaymentService());
		OrderService.placeholder();
	}
}

// PaymentService.java
public interface PaymentService {
    void ProcessPayment(double amount);
}

// OrderService.java
public class OrderService {
    private PaymentService paymentService;
    public void setPaymentService(PaymentService paymentService) {
        this.paymentService = paymentService;
    }
    // Constractor Injection "Open Closed Principal"
    public OrderService(PaymentService paymentService) {
        this.paymentService = paymentService;
    }
    public void placeholder() {
        paymentService.ProcessPayment(10.3);
    }
}

// PaypalPaymentService.java
public class PaypalPaymentService implements PaymentService {
    @Override
    public void ProcessPayment(double amount) {
        System.out.println("Paypal");
        System.out.println("Amount: " + amount);
    }
}

// StripePaymentService.java
public class StripePaymentService implements PaymentService {
    @Override
    public void ProcessPayment(double amount) {
        System.out.println("STRIPE!");
        System.out.println("Amount : " + amount);
    }
}




// The Spring Ioc container && configuration beans using annotations
/*
    Example: If Employee depends on Address, for using
        Employee we need to create Address.
        --> With Ioc Spring do it auto

    Ioc: Inversion of Control
        for this we need to do the Beans Configuration:
            --> Using Annotations --> [@Component, @Service, @Repository, @Controller]
            --> Using code

    'in this code bellow we Inject "PaypalPayment" Class Auto'
*/
// Classic Way:
var OrderService = new OrderService(new PaypalPaymentService());
OrderService.placeholder();

// With Ioc
public static void main(String[] args) {
    ApplicationContext context = SpringApplication.run(LearnSpringStoreApplication.class, args);
    var orderService = context.getBean(OrderService.class);
    orderService.placeholder();
}

// OrderService.java
@Component
public class OrderService {
    private PaymentService paymentService;
    public void setPaymentService(PaymentService paymentService) {
        this.paymentService = paymentService;
    }
    // Constractor Injection "Open Closed Principal"
    @Autowired --> if we have multiple constractor
    public OrderService(PaymentService paymentService) {
        this.paymentService = paymentService;
    }
    public void placeholder() {
        paymentService.ProcessPayment(10.3);
    }
}

// PaypalPaymentService.java
@Component
public class PaypalPaymentService implements PaymentService {
   @Override
   public void ProcessPayment(double amount) {
       System.out.println("Paypal");
       System.out.println("Amount: " + amount);
   }
}












